[{"title":"Java synchronized 关键字","path":"/2025/07/23/java-synchronized/","content":"锁的对象 this 对象，当前对象 指定共享对象 Class 对象，XXX.class 全局唯一的对象，是java.lang.Class 的实例 对静态方法加锁也是Class 对象实例进行加锁 锁在方法上，为this 锁，静态方法为全局Class 锁 原理JVM 层面提供一个minitor 锁的机制，对使用了synchronized 关键字的代码块模块加上了monitorenter 指令和monitorexit 指令。 public class Demo public void foo() synchronized(this) System.out.println(Hello World!); public static void main(String[]args) Demo demo = new Demo(); demo.foo(); 使用javap -verbose 命令可以得到反编译的字节码，能看到monitorenter 和monitorexit 指令，如下所示 对于使用synchronized 关键字修饰的方法，JVM 并不会像代码块一样加上monitorenter 和monitorexit 方法，而是在方法的flags 处加上 ACC_SYNCHRONIZED 标志。 当JVM 调用方法时识别到有这个标记时，判断是否为静态方法，根据方法的类型对不同的对象加索（实例Class 实例） 。保证同步代码块的安全性。 如果JVM 识别到这个同步方法实际并不存在竟态情况的时候，会进行锁消除等优化。 public class Demo public synchronized void foo() System.out.println(Hello World!); public static void main(String[]args) Demo demo = new Demo(); demo.foo(); 反编译字节码如下 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。 根据锁的级别，可重入锁的依据也不同，取决于锁实例的对象头，根据锁的等级实现的原理也不一致。 偏向锁是根据对象头存储的偏向的线程id，锁重入的时候，markword 里面的线程id 是不会发生任何变化的 轻量级锁根据markword 中存储的指向lock record 的指针，在重入的时候也是没有变化的 重量级锁，在重入的时候，指向的object monitor 里面有一个_recursion 字段是会进行递增的 happens-before根据JMM 的monitor lock rule 原则，释放锁的时候会强制刷新工作内存到主内存，加锁的时候也强制要求从主内存重新加载数据 锁优化方法JDK 1.6 在JVM 层面对锁进行了优化。根据实时情况控制锁的粒度 锁粗化：识别到同时操作多个同步操作，一把锁，直接优化成一把锁，而不是多把锁 锁消除： 根据JIT + 逃逸分析，直接把锁干掉 适应性自旋 偏向锁 轻量级锁 锁的类型 无锁 偏向锁 轻量级锁 重量级锁 （不可逆） 自旋锁： JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数-XX:PreBlockSpin来更改。 自适应自旋锁 根据上一个线程等待的时间和次数来决定当前线程自旋等待的时间和次数 锁消除 基于JIT 逃逸分析，认定加了锁的代码实际上并没有race condition ，会把锁进行消除 jdk 1.5 后，stringbuffer 如果没有race condition 则会编译为string builder 轻量级锁和偏向锁 基于对象头中的markword 作为共享变量来实现，jvm 层级的cas 指令判断当前对象锁被哪个线程占用。 拓展：JVM 对象头 锁升级锁升级的主要体现在对象头的markword 上，markword是一个动态的对象 无锁时 存储hashcode + 锁标记 偏向锁时存储偏向锁线程id，如果已经计算过hash code 则无法使用偏向锁 轻量级锁 存储Lock record 地址，Lock record 中会复制一份markword，如果在升级为轻量级锁之前使用了hashcode方法，则hashcode 则会在里面，如果没有那么hashcode 生成但需要调用，锁就会升级为重量级锁 重量级锁：生成object monitor 对象，需要进行内核到用户态的切换，markword 存储object monitor 的位置，生成的object monitor 会复制一份旧的markword对象 图来自掘金文章：https://juejin.cn/post/6978882583492821023 上述标志位可以使用JOL 工具进行观察得到 package org.example;import org.openjdk.jol.info.ClassLayout;public class SynchronizedLockUpgradeDemo public static void main(String[] args) throws InterruptedException //创建锁对象 Object lock = new Object(); //JVM 存在偏向锁启动延迟，延迟几秒，或者通过-XX:BiasedLockingStartupDelay=0 禁用 Thread.sleep(5000); System.out.println(================ 1. 初始状态：无锁 ================); System.out.println(ClassLayout.parseInstance(lock).toPrintable()); System.out.println(================ 2. 锁升级为偏向锁 ================); synchronized (lock) System.out.println(ClassLayout.parseInstance(lock).toPrintable()); System.out.println( 退出同步块后，锁对象依然保持偏向锁状态，偏向于主线程); System.out.println(ClassLayout.parseInstance(lock).toPrintable()); System.out.println(================ 3. 锁升级为轻量级锁 ================); Thread thread = new Thread(() - synchronized (lock) System.out.println(ClassLayout.parseInstance(lock).toPrintable()); ); thread.start(); thread.join(); System.out.println(================ 4. 锁升级为重量级锁 ================); Thread thread2 = new Thread(() - synchronized (lock) try Thread.sleep(3000); catch (InterruptedException e) e.printStackTrace(); ); Thread thread3 = new Thread(() - try Thread.sleep(100); catch (InterruptedException e) e.printStackTrace(); synchronized (lock) System.out.println(ClassLayout.parseInstance(lock).toPrintable()); ); thread2.start(); thread3.start(); thread2.join(); thread3.join(); System.out.println( ================ 5. 重量级锁释放后 ================); System.out.println(所有线程执行完毕后，锁被释放，但可能不会立即变回无锁状态); System.out.println(ClassLayout.parseInstance(lock).toPrintable()); 标志位变化过程：从无锁（可偏向 101 ） 偏向锁 （101） 轻量级锁(00) 重量级锁 (10) 输出如下 C:\\Program Files\\Java\\jdk1.8.0_251\\bin\\java.exe -javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2025.1.2\\lib\\idea_rt.jar=64753 -Dfile.encoding=UTF-8 -classpath C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext ashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_251\\jre\\lib\\rt.jar;F:\\code\\source\\target\\classes;C:\\Users\\A80236\\.m2\\repository\\org\\openjdk\\jol\\jol-core\\0.17\\jol-core-0.17.jar org.example.SynchronizedLockUpgradeDemo================ 1. 初始状态：无锁 ================java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000005 (biasable; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total================ 2. 锁升级为偏向锁 ================java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000003803005 (biased: 0x000000000000e00c; epoch: 0; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total退出同步块后，锁对象依然保持偏向锁状态，偏向于主线程java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000003803005 (biased: 0x000000000000e00c; epoch: 0; age: 0) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total================ 3. 锁升级为轻量级锁 ================java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000035a1f210 (thin lock: 0x0000000035a1f210) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total================ 4. 锁升级为重量级锁 ================java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000033be1c8a (fat lock: 0x0000000033be1c8a) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total================ 5. 重量级锁释放后 ================所有线程执行完毕后，锁被释放，但可能不会立即变回无锁状态java.lang.Object object internals:OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000033be1c8a (fat lock: 0x0000000033be1c8a) 8 4 (object header: class) 0xf80001e5 12 4 (object alignment gap) Instance size: 16 bytesSpace losses: 0 bytes internal + 4 bytes external = 4 bytes totalProcess finished with exit code 0 配置偏向锁开关 -XX:+UseBiasedLocking # 启用偏向锁（默认） -XX:-UseBiasedLocking # 禁用偏向锁 -XX:BiasedLockingStartupDelay0 # 禁用偏向锁延迟","tags":["Java"]},{"title":"Hello World","path":"/2025/04/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"「设计模式」责任链模式","path":"/2024/04/26/chain-of-responsibility/","content":"引言在软件开发过程中，经常会遇到需要对请求进行一系列处理的情况。例如，在Web应用中，用户的请求可能需要经过身份验证、权限检查、数据校验等步骤。为了使代码结构清晰、降低耦合度、提高可扩展性，可以使用责任链模式来解决此类问题。 责任链模式定义责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它通过将多个处理者（Handler）按照顺序组成一条链，当有请求发生时，沿着这条链依次传递，直到有处理者处理它或处理链结束。该模式使请求的发送者和接收者解耦，客户端无需知道是哪一个处理者最终处理了请求，增强了系统的灵活性。 比如在一个采购系统中，用户需要进行采购下单，对采购的商品会进行很多校验，比如用户是否符合采购用户标准，用户采购的订单库存是否充足，用户需要送达的地址是否可以送到等等一系列校验。按照需求快速开发我们就会在一个校验的方法里面，判断上述一系列条件是否满足，满足才可以生成订单。后面系统进行二次迭代，vip 用户不需要下单，也不需要进行地址校验，这时候可能会加入一个if vip user 的判断 然后再决定是否执行校验，这样简单一次代码结果还好，但是随着系统的不断迭代，特定场景的订单越来越多，判断条件也越加越多，于是乎代码结果就变得难以阅读和维护。 参考Servlet 的Filter + FilterChain， 可以构建一个订单创建的职责链路，根据业务类型来指定对应的职责链路。 Servlet 里面的Filter 和FilterChain 使用的就是责任链模式。每一个职责可以组装，比如filterchain 也有不同的实现 Filter 接口 - 实现处理过程 FilterChain 接口 - 定义调用链路 责任链模式建议你将这些处理者连成一条链。 链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。 除了处理请求外， 处理者还负责沿着链传递请求。 请求会在链上移动， 直至所有处理者都有机会对其进行处理。 写点代码以订单创建为例子，会对订单的信息校验，然后再进行创建，如果不满足条件则退出，每种特定的行为的处理都会影响订单创建的结果。 快速开发if-else 一把锁 public class OrderService void creteOrder() OrderBO orderBO = new OrderBO(); if (checkState(orderBO)) //do something if(checkAddress(orderBO)) //do something if (checkXXX(orderBO)) //create order private boolean checkXXX(OrderBO orderBO) return false; private boolean checkAddress(OrderBO orderBO) return false; private boolean checkState(OrderBO orderBO) return false; 使用责任链模式拆分业务逻辑 OrderBO ，订单业务对象 OrderFilter ，订单处理过滤器接口 OrderAddressFilter 实现 OrderFilter OrderStateFilter 实现OrderFilter OrderFilterChain构建订单过滤链路， 包含doFilter 和addFilter 方法，维护一个过滤器链表 OrderFilterTest指定需要的链路，然后执行过滤。具体代码如下所示 //订单创建过滤器public interface OrderFilter void doFilter(OrderBO order, OrderFilterChain chain); ​//地址校验过滤器@Slf4j @Component(OrderFilterConstant.ADDRESS) public class OrderAddressFilter implements OrderFilter @Override public void doFilter(OrderBO order, OrderFilterChain orderFilterChain) log.info(执行地址过滤); orderFilterChain.doFilter(order); //订单状态校验过滤器@Component(OrderFilterConstant.State) @Slf4j public class OrderStateFilter implements OrderFilter @Override public void doFilter(OrderBO order, OrderFilterChain orderFilterChain) log.info(执行订单状态过滤); orderFilterChain.doFilter(order); 订单创建责任链 @Slf4j @Component public class OrderFilterChain private int size; private int position = 0; private OrderFilter[] orderFilters = new OrderFilter[10]; public void doFilter(final OrderBO order) //必须加判断，否则链式调用会死循环，直到StackOverflow if (this.position this.size) OrderFilter orderFilter = orderFilters[position++]; orderFilter.doFilter(order, this); public void addFilter(OrderFilter orderFilter) if (orderFilters.length == size) OrderFilter[] newOrderFilters = new OrderFilter[size + 10]; System.arraycopy(orderFilters, 0, newOrderFilters, 0, size); orderFilters = newOrderFilters; orderFilters[size++] = orderFilter; 客户端测试代码 ​@SpringBootTest public class OrderFilterTest @Autowired private OrderFilterChain orderFilterChain; @Autowired private MapString, OrderFilter orderFilterMap; @Autowired private ListOrderFilter orderFilters; @Test public void test() for (OrderFilter orderFilter : orderFilters) orderFilterChain.addFilter(orderFilter); // orderFilterChain.addFilter(orderFilterMap.get(OrderFilterConstant.ADDRESS)); // orderFilterChain.addFilter(orderFilterMap.get(OrderFilterConstant.State)); orderFilterChain.doFilter(null); 如果想要指定新的责任链，比如A业务不需要进行某个校验，那么在client 调用的时候，就不要添加到filterChain 即可 总结在上面的案例中，我们把订单创建的每一个职责抽取成了单独的Filter ，每一个filter 可以通过FilterChain 进行链式调用。如果后续有新的责任链路的时候，可以在调用方指定校验链路的顺序和类型，实现对应的业务逻辑处理。 在使用责任链模式之后，后续迭代时既不需要修改原有的代码，也可以重新编排新的FilterChain。","tags":["设计模式","责任链","面向对象"],"categories":["设计模式"]},{"title":"Spring 常用注解总结","path":"/2022/04/05/spring-annotations/","content":"Spirng 常用注解总结 组件注解@Component 组件注解，Spring boot 会将指定路径下标注了@Component 注解的类自动加载，默认单例加载，如果要声明对多例，则需要使用@Scope 注解进行定义声明。 @Componentpublic class UserServiceImpl 多例BEAN import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component@Scope(prototype)public class PrototypeBean // 类的实现 目标对象是类级别 @Service是@Component 的别名，作用同@Component 声明业务层 @Servicepublic class UserServiceImpl @Repository是@Component 的别名，作用同@Component 数据访问层 @Repositorypublic class UserRepositoryImpl @Controller是@Component 的别名，作用同@Component @Controllerpublic class UserController @RestControllerREST API 注解。是@Controller 和@ResponseBody 的的组合 Spring Web @Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController ​ /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) * @since 4.0.1 */ @AliasFor(annotation = Controller.class) String value() default ;​ 配置相关@Configuration声明一个类中的多个@Bean方法可以会被spring 容器处理 public class AppConfig ​ @Bean public MyBean myBean() // instantiate, configure and return bean ... @Bean声明一个类会生成一个bean 将被Spring 容器管理 @Bean public MyBean myBean() // instantiate and configure MyBean obj return obj; @Value用于方法或者构造器参数，声明一个默认的表达式，可以用于读取外部配置文件 @ConfigurationProperties与@Configuration 结合使用，绑定外部配置的properties 或者yaml文件 @Configuration@ConfigurationProperties(prefix = xxx.xx)public class ParamsConfig 相较于Value 注解，ConfigurationProperties 可以注入复杂类型；比如list 、map 等 配置类 import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;@Component@ConfigurationProperties(prefix = complex.config)public class ComplexConfigProperties private ListString simpleList; private MapString, String simpleMap; private ListNestedObject nestedList; // standard getters and setters public static class NestedObject private String name; private int value; // standard getters and setters 配置文件 complex: config: simpleList: - listValue1 - listValue2 simpleMap: key1: value1 key2: value2 nestedList: - name: nestedName1 value: 1 - name: nestedName2 value: 2 注入注解@Autowried在Spring Boot 自动装配了上面的类之后，如果想在类中使用其他组件的类，可以使用 @Autowried 注解进行注入 @Qualifier当定义了一个Service Interface 存在多个实现时，一般都是按照名称进行注入对应的实例，如果需要按照名称指定对应的类的话，就可以使用@Qualifier 注解指定对应名称的Service 功能注解功能注解通常是基于Spring AOP 进行动态代理实现，所以在使用时要注意代理是否生效。 @Transcational事务注解，可通过订单指定的异常类进行触发，默认为Throable.class 触发事务回滚 事务隔离级别（4个）： 读未提交 读已提交 可重复读 串行化 事务传播级别（7个）： REQUIRED ，当存在事务时则继续使用当前事务，如果当前不存在事务，则创建一个新的事务 SUPPORTS，当前存在事务则继续使用当前事务，如果不存在事务则不创建 MANDATORY，支持当前事务，如果当前不存在事务则抛出异常 REQUIRES_NEW ，不论存在还是不存在事务，都创建一个新的事务 NOT_SUPPORTED，如果存在事务则暂停当前事务，声明当前方法不在事务内执行 NEVER，不支持事务，如果当前存在事务则抛出异常 NESTED @Retryable 和@Recover 需要引入spring-retry 并且开启重试配置 重试注解，与事务注解一样，当抛出指定异常时会进行回滚，可以指定重试次数、重试策略（重试时间、每次增加多少秒） @Retryable(value = Throwable.class, backoff = @Backoff(multiplier = 2))void pushMessage() @Aync异步注解，方法级别的注解，在方法上标注@Aysnc 在正常调用下，方法里面的业务逻辑会异步执行，默认放到spring 的taskExecutor 这个线程池里面执行，线程池可通过配置类统一配置 @Asyncvoid pushMessage() 链接 Spring 源码分析 字节码增强技术 Spring Boot 源码分析","tags":["Spring","注解"],"categories":["Spring"]},{"title":"关于我","path":"/about/index.html","content":"关于我。"}]